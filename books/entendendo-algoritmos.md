# Entendendo Algoritmos — Aditya Y. Bhargava

**Categoria:** Algorithms & Data Structures  
**Avaliação pessoal:** ★★★★★  

---

## Capítulo 1 — Introdução a algoritmos
- Algoritmo = conjunto de instruções.  
- Pesquisa binária: O(log n), vs busca linear: O(n).  
- Notação Big O descreve crescimento do custo.  
**Resumo IA:** O capítulo mostra como a pesquisa binária reduz drasticamente o número de operações e introduz a notação Big O para comparar algoritmos.

---

## Capítulo 2 — Ordenação por seleção (arrays e listas encadeadas)
- Arrays: acesso aleatório O(1), inserções caras.  
- Listas: inserções baratas, acesso aleatório O(n).  
- Ordenação por seleção: O(n²).  
**Resumo IA:** Compara arrays vs listas encadeadas e introduz ordenação por seleção como motivação para algoritmos mais rápidos.

---

## Capítulo 3 — Recursão
- Definir caso-base e caso recursivo.  
- Pilha de chamadas consome memória.  
**Resumo IA:** Recursão simplifica o raciocínio, mas deve ser usada com cuidado por conta do consumo de pilha.

---

## Capítulo 4 — Quicksort (Dividir para conquistar)
- Divide e conquista = subproblemas menores + combinação.  
- Quicksort: médio O(n log n), pior caso O(n²).  
**Resumo IA:** Algoritmo rápido na prática; escolha do pivô define eficiência.

---

## Capítulo 5 — Tabelas hash
- Funções hash para mapear chaves.  
- Colisões (encadeamento, open addressing).  
- Fator de carga influencia desempenho.  
**Resumo IA:** Estrutura poderosa para buscas rápidas, mas depende de uma boa função hash.

---

## Capítulo 6 — Pesquisa em largura (BFS)
- Grafos: nós + arestas.  
- BFS encontra caminho mais curto em grafos não ponderados.  
- Complexidade: O(V+E).  
**Resumo IA:** Algoritmo simples que garante o menor número de arestas entre dois nós.

---

## Capítulo 7 — Algoritmo de Dijkstra
- Caminho mínimo em grafos ponderados (pesos não-negativos).  
- Estruturas influenciam desempenho (heap).  
**Resumo IA:** Essencial em grafos ponderados; ineficaz com pesos negativos.

---

## Capítulo 8 — Algoritmos gulosos
- Escolhem sempre a opção localmente ótima.  
- Funcionam em alguns problemas (interval scheduling, mochila fracionária).  
- Aproximações em problemas NP-completos.  
**Resumo IA:** Estratégia prática e rápida, mas não garante sempre a solução ótima.

---

## Capítulo 9 — Programação dinâmica
- Resolve subproblemas sobrepostos.  
- Problema da mochila, LCS como exemplos.  
**Resumo IA:** Constrói soluções complexas a partir de tabelas de subproblemas, transformando exponencial em polinomial.

---

## Capítulo 10 — K-vizinhos mais próximos (KNN)
- Classificação e regressão baseadas em proximidade.  
- Importância das features e da normalização.  
**Resumo IA:** Método intuitivo e versátil, mas pesado para consultas grandes.

---
- Sugestões: árvores, MapReduce, filtros probabilísticos, criptografia, programação linear.  
**Resumo IA:** Lista de caminhos para aprofundamento em algoritmos e ciência da computação.
